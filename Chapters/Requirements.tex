\linebreak
Based on the analysis of existing solutions, I will now describe the most important features that should be provided by my software.

I decided to construe the user-focused features (usually functional requirements) as one would in a real-life agile project, as this is in my experience more straightforward and easier to alter when necessary than flooding the reader -- for example, a developer -- with a long list of elaborate use cases right away.
The discussions that took place before reaching a specific conclusion should be well documented -- brief enough and detailed enough at the same time to provide good value after a quick read.
If the reader has access to a good transcript of these discussions, it is less likely that they will misunderstand the requested functionality;
in the best case scenario, if the reader is the potential developer, they are an active part in those discussions, so they have a substantial impact on the outcome, thus diminishing the `coding monkey' phenomenon.

The top-down approach of the agile methodology which is perhaps the most common and natural to grasp is creating epics, decomposing them into user stories, and with good knowledge of the project's architecture and after due consideration, technical subtasks in an issue tracker of choice.

Epics are complex, high-level characterizations of desired functionality, which usually take longer to deliver than a few weeks.
An epic is usually comprised of a description and multiple user stories, which cover the extent of the epic in higher granularity.
Once all the stories are delivered, the whole epic is considered finished.
Epics are sometimes formulated using the same format as user stories.

User stories (US) are short, simple descriptions of a feature told from the perspective of the person who desires the new functionality, usually a user of the system.\cite{user-story-definition}
Often they are written in simple, non-technical language, as most systems don't have tech-savvy users.
The typical template for a user story is:
\textit{As a < type of user >, I want < some goal > so that < some reason >.}\cite{user-story-definition}
Sometimes the US's aren't technical per se, but request deeper analysis and block further progress on the epic.

The main focus of this chapter will be to document my internal discussions, occassionally consulted with developer friends. \todo{cite? delete completely?}
I will always start with a high-level description of the requested feature formulated as an epic or a user story and elaborate on its details incrementally.
Since a part of this thesis will focus on implementing a proof of concept, some of the most imperative stories will also be fully processed and finished.

Features
\begin{itemize}
    \item F -- Track selection
    \item F -- Heart rate monitoring
    \item F -- Objective user fitness assessment
    \item F -- Calculation of selected track's difficulty relative to user's fitness
    \item F -- Map integration
    \item F -- Track details display
    \item F -- Track segment details display
    \item F -- How long the track will take
    \item F -- History of tracks the user has chosen
    \item F -- Mood of user after finishing of track
    \item F -- Option to insert fitness level manually instead of using the built-in calculator (maybe the user has done a lab test)
\end{itemize}

\subsection*{E01 -- Heart rate monitoring}
The application should monitor a user's heart rate inobtrusively and reliably.

The user needs a method for getting their data to the mobile application and then to the backend, do it comfortably, preferably without need for direct user-computer interaction.

\subsection*{E01-US01 -- Choose and integrate a wearable}
As an APP user, I want my heart rate-enabled wearable to work with the APP, so that I don't have to buy a new one.

Based on the analysis of existing applications, the most often used type of wearable tech are smart watches.
While most applications support other devices, such as chest straps, watches are the most convenient and wide-spread gadgets to be used by the general public.
There are a few quite popular smart watch vendors, most of whom have proprietary protocols of communicating with the system for data processing.\todo{recheck}
At the time of writing, however, Garmin seems like the most popular option, in spite of being more than a little costly.

It will be more difficult to integrate some devices.
Some vendors don't disclose their devices' API, or the API's documentation is only in Chinese and available to for use exclusively by partners of the given vendor,
some don't get paired with the phone itself but with a vendor app using server based pairing (such as the Xiaomi Mi Band 4 I initially intended to use) and there is no easy or straight-forward way to get the data.
For example, getting data from the Mi Band 4 would require root access to the user's phone\cite{miband4-server-based}, which is just not an option for a normal user.
Therefore I recommend limiting the supported devices to those that do not use server based pairing, as this would cover most of the currently available gadgets.

For my PoC in this thesis, I chose the XXXXXXXXX.\todo{add what and why}

\subsection*{E01-US02 -- Manage devices paired with the APP}
As an APP user, I want to pair and unpair my wearables with the APP, so that the APP can use the data of all devices that I currently own.

The user should be able to pair and unpair any number of wearables they choose.
The app should provide the user with the list of the phone's paired devices, so that they can choose their fitness gadgets.

Restrictions on which data gets processed if multiple devices are measuring the same biometric is described in E01-US03.

\subsection*{E01-US03 -- Activate a device}
As an APP user, I want to mark a wearable I'm using as active, so that only its data is relevant to the statistics.

The user should be able to activate a device they want to use for monitoring of current activity or activity in the near future.
Only one device should be active at a time, so if device A is marked as active and user tries to activate device B, device A gets deactivated before device B is marked as active.

\subsection*{E02 -- Objective user fitness assessment}
As an APP user, I want my fitness to be assessed, so that I can get relevant estimations of track difficulty.

Having analyzed the conventional ways of user fitness assessment in a previous chapter, the application should allow a user to use one of multiple ways to get their fitness level.
The outcome of the assessment should be the individual's VO2 max index and their heart rate zones -- so that if they need to maintain their heart rate in a specific range, they can cross-reference it with the exhaustion they perceive and learn to recognize when they are in the desired zone.

If the user has no physical impairments, they can have their HR max assessed by a simple age-based formula, such as the one developed by Nes et al. (see chapter on fitness assessment).

Users with physical impairments could self-evaluate how much their condition affects their fitness, and based on this their HR max can be set by using one of the standard formulas and subtracting a smaller or larger number of beats per minute (further research needs to be done on how many beats this should be).
This self-assessed value should be corrected as more data is available about the user.

As far as objective assessment, I see plenty of potential for the use of neural networks.
The networks can learn from the data collected from a good number of users over a longer period, and then categorize the new users into fitness groups based on this data, which will then be used to predict the users' future hikes.

\subsection*{E02-US01 -- Implement support for VO2 max tests}
As an APP user, I want to be able to take a guided test of my fitness in the APP, so that I don't have to look for tests elsewhere.

The APP should implement a guide to multiple tests of VO2 max, with instructions on what they should do, and signals to direct the user while taking the test.
The instructions should also contain a description of the signals the user will receive.
The initial instructions should definitely be textual and possibly audible, so that the user understands the aim of the test before taking it.
During the test, a watch vibration should alert the user about an incoming signal which will be displayed on the watch.
This signal would contain directions like 'Turn in N seconds' where N is a countdown to 'Turn now!'.
When no signals are occupying the device's screen, there should be pep talks like 'Keep going!' and 'Great job!'.
At all times during the test, there should be the test status on the device's screen: remaining time, distance walked, and any other metric relevant to the test.

As it is the most accurate of the more feasible tests, the application should encourage the user to take the 6-Minute Walking Test, and let them take it using the app in both 15- and 30-metre-long variations.
In order to calculate VO2 max, the APP can use Mänttäri's formulas.

\subsection*{E02-US02 -- Implement support for HR max tests}
As an APP user, I want to be able to take a guided test to find my heart rate zones in the APP, so that I don't have to look for tests elsewhere and get as accurate heart rate zones as possible.

The implementation should be similar to VO2 max tests; in fact, if possible, both metrics should be measured by a single test if possible.

\subsection*{E02-US03 -- Allow other input of biometric values}
As an APP user who has done lab fitness tests, I want the APP to use these values instead of doing the APP's tests, so that I don't have to take fitness tests that are most probably less accurate than what I know.

If a public universal database with all people's medical data existed, it would make sense to get the necessary information directly via an API.
In the real world, however, we will let the user enter their biometric data manually.
The APP definitely needs easily available data like age, sex and weight.
Then it should be possible to either take tests on or manually enter the VO2 max, resting heart rate and maximum heart rate.

